---
title: MySQL
date: 2023-06-11 21:00:10
categories: MySQL
tags: MySQL
---

# MySQL

## 基本

**SQL分五个部分**

> DQL：数据查询语言，
>
> DML：数据操作语言。
>
> - ```mysql
>   插入  insert into 表名 values(数据);
>   插入  insert into 表名（字段名） values(数据);
>   ```
>
> ```
> 
> ```
>
> ```
> 
> ```
>
> ```
> 
> ```
>
> - ```mysql
>   更新  update 表名 set 字段名 = 数据； 修改全表
>   更新  update 表名 set 字段名 = 数据 where 条件；修改单行 
>   ```
>
> ```
> 
> ```
>
> ```
> 
> ```
>
> - ```mysql
>   删除  delete 表名 where 条件; 删除单行
>   ```
>
> ```
> 
> ```
>
> ```
> 
> ```
>
> DDL：数据定义语言（表，试图，触发器，存储过程，函数）创建、删除和修改。
>
> - ```mysql
>   创建表  create table 表名（ 字段名 类型）;  
>   
>   ```
>
> ```
> 
> ```
>
> - ```mysql
>   查看表结构 desc 表名;
>   查看创建表语句 show create table 表名;
>   
>   ```
>
> ```
> 
> ```
>
> ```
> 
> ```
>
> - ```mysql
>   新增一列   alter 表名 add 字段名 数据类型;
>   
>   ```
>
> ```
> 新增一列（在首位）   alter 表名 add 字段名 数据类型 first;
> 
> 新增一列（在中间某列后面）   alter 表名 add 字段名 数据类型 after 表名;
> 
> ```
>
> - ```mysql
>   删除外键 alter table 表名 drop foreign key 键名
>   
>   ```
>
> ```
> 
> ```
>
> - ```mysql
>   删除一列 alter 表名 drop 字段名：
>   删除表 drop 表名
>   
>   ```
>
> ```
> DCL：数据控制语言
> TCL：事务控制语言
> 
> ```

```mysql
DDL和DML的补充：
-- 添加一张表，快速添加：结构和数据跟某表都是一致的
create table 表名
as 
select * from 某表；

-- 快速添加：结构跟某表一致，但数据没有
create table 表名
as
select * from 1 = 2

-- 快速添加：只要部分列，部分数据：
create table 表名
as
select 字段1，字段2 from where 条件

-- 删除表所有数据
delete from 表名；
truncate table 表名；

delete 和 truncate的区别：
（1）delete属于DML，truncate属于DDL，
（2）delete是一行一行删除数据，而truncate保留了表的结构，重新创建了一张新的表，效率更高。
（3）delete可以回滚，truncate不可以回滚，会导致隐式提交，
（4）Delete删除完成时会返回对应影响的行数，而truncate只返回0，并且Detele删除时自增数会从最大数+1开始，而truncate会从新从1开始。

```

```mysql
DQL的补充
-- 排序
当使用查询order by，有两个值以上需要排序时，会根据第一个值先全部排序好，再根据后面第二个值进行排序。

-- 大小写
当要查找某个确定值时，默认不区分大小写，如果区分大小写，则需要在where语句后面直接加个binary

-- null的判断
要使用is null 或者 is not null

-- having
having关键字使用在order by后面，表示分组以后二次筛选，而where表示在分组之前进行筛选


-- group by后面可跟多个参数，分好组好可以利用having对其他列
-- 左连接可以用来判断右边是否需要

```

### 表的约束

> 为防止不符合规范的数据存入数据库，在用户对数据进行插入、修改和删除操作时，提供了一种机制来检查数据库的数据是否满足规定条件，以保证数据库中的数据准确性和一致性，这种机制就是完整性约束。
>
> 约束分为两类
>
> （1）**表级约束**：可以约束表中任意一个或多个字段。与列定义相互独立，不包含在列定义中；与定义用‘，’分隔；；必须指出约束的列的名称；
>
> （2）**列级约束**：包含在列定义中，直接跟在该列的其他定义之后，用空格分割；不必指定列明；
>
> ![](https://s3.bmp.ovh/imgs/2023/04/10/a0f566a7c4fa2c1f.png)

（1）表级约束例子（两种，表内和表外，其中外键约束也属于表级约束）

- ![](https://s3.bmp.ovh/imgs/2023/04/10/221e65dfeb4018d4.png)
- ![](https://s3.bmp.ovh/imgs/2023/04/10/f70ea96dfba82957.png)



（2）列级约束例子

![](https://s3.bmp.ovh/imgs/2023/04/10/5babfa01bf639cd7.png)

（3）（表外约束例子）

> 外键约束：用来实现数据库表的参照完整性的。可以使两张表紧密的结合起来，特别是针对修改或者删除的级联操作时，会保证数据的完整性。
>
> 外键是指表中某个字段的值依赖于另一张表中的某个字段的值，而被依赖的字段必须具有主键约束或者唯一约束。被依赖的表表通常我们称之为父表或者主表，设置外键约束的表成为子表或者从表。

![](https://s3.bmp.ovh/imgs/2023/04/10/1edd606cf9937a2f.png)

### 函数

> 定义：相当于Java的方法，封装了特定的一些功能。作用：提高效率。注意：函数并未改变 表中的值， 只是将真实的数据加工处理，展示新的结果。
>
> 分为：单行函数和多行函数。
>
> - **单行函数**：每条记录作为一个输入参数，经过函数计算得到每条记录的结果。
> - **多行函数**：对一组数据进行计算，针对这组数据只返回一个结果，也成为分组函数。
>
> 除了多行函数（max，min，count，sum，avg），其他的都是单行函数。

> 小提示：select count(1) from 表，是从select 1 from 表演化过来，select 1表示返回表中所有1，比如表中有10行数据，就返回10行1，之后select count(1)就能全部查出来了。

单行所有函数：https://blog.csdn.net/Sihang_Xie/article/details/125726868

### 连接查询

> 连接就是将多张表联系起来，一些表中的数据在其他表中存储时，这个时候就需要连接起来查询。
>
> 连接分为两大种：
>
> 内连接：1、交叉连接（笛卡尔积）cross join，2、自然连接 natural join，3、内连接 - using子句，4、内连接 - on子句。
>
> - 交叉连接 - 当有两张表都有十行数据时，会交叉排列出来10 * 10 = 100条
> - 自然连接 - 当表中有重复的列名时，会交叉排列出来。（缺点：会自动匹配所有同名列，不能指定）
> - 内连接using - 当有同名列时，可以指定列名（缺点：当需要指定不同列名，但该列的数据一样时，无法指定）
> - 内连接on - 解决了以上所有问题。（缺点：只显示不为空的）
>
> 外连接：除了可以显示匹配的数据外，还可以显示不匹配的数据。1、左外连接 - left outer join on，左边的那个表即使也可以匹配信息，2、右外连接。
>
> 小提示：当需要查询两张表彼此都没有的数据时，这个时候需要查询两张表的左连接和右连接，然后中间加一个union，并集比如：左连接14条，13条为有的，1条为没有的，右连接同理，这个时候只需要查                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      询并集即可，一共15条数据。union all是把所有并集交叉

### 事务

> **作用：用来维护数据库的完整性，它能够保证一系列的Mysql操作要么全部执行，要么全不执行。Innodb才有事务。**
>
> **一个DML操作就是一个事务，所以我们需要手动开启事务 - start transaction， 手动回滚 - rollback，手动提交 - submit，在事务提交和回滚之前，操作的都是缓存中的数据**

**事务的特性：ACID（原子性，一致性，隔离性，持久性）**

- **原子性：所有操作划作为一个整体，不能在划分，要么整体全部执行，要么全部不执行**

  原理：通过undolog实现，会先把数据备份到一个地方，然后发生错误时，需要回滚，就会执行undolog文件的语句，比如我插入一条数据，那么undolog会记录删除一条数据，删除则记录回复。

- **一致性：操作过后的数据要保持的数据一致，比如转账前后，金额总额不变**

  原理：通过其他三个保证实现

- **隔离性：事务与事务之间相互隔离**

  读写：会有线程安全问题，需要进行并发控制（锁）MVCC，写写：更新丢失问题。

  **MVCC：多版本并发控制，解决数据并发读写问题。**https://www.bilibili.com/video/BV1xq4y1q72k?p=85&spm_id_from=pageDriver&vd_source=dd5d1ef71c78ae671bcb138273ecb421

- **持久性：操作完之后会永久性的保存下来，通常保存在数据库中，数据库损坏，也应该有机制恢复**

  原理：redolog日志，https://www.bilibili.com/video/BV1xq4y1q72k?p=84&spm_id_from=pageDriver&vd_source=dd5d1ef71c78ae671bcb138273ecb421

**事务引发的问题：**

- **脏读（一个事务在读时，另一个事务在更新没有提交，第一个事务继续读时，发现数据发生改变）**
- **不可重复读（一个事务在读取，另一个事务在更新并且提交，第一个事务继续读时，发现与之前重复读取的数据不一样）**
- **幻读（一个事务在读取行数，另一个事务在插入新的数据并且提交，第一个事务继续读时，发现与之前读取的行数不一样，多了一些不存在数据，就好像幻觉一样，莫名其妙）**

**不可重复读和幻读看起来一样：其实最大的区别在于不可重复读是在数据更新，幻读是在插入或者删除数据，不可重复读解决只需要锁住单独的一行即可，幻读就需要锁住的是整张表。 **

**事务的隔离级别：**

**为了解决事务引发的问题，引入了隔离级别：**

- **读未提交：三个问题都没解决**
- **读提交：解决了脏读**
- **可重复读：为解决幻读**
- **序列化：解决了全部（锁了全张表）**

### 视图

> 一张或者多张整理出来的虚拟表

### 存储过程

> 相当于一个函数

## 索引

> 可以把懂得全讲了。索引底层就是一种数据结构，这种数据结构是为了加快我们查询的效率，相当于一本书的目录。查询数据的时候我们可以使用AVL树，红黑树，B树，B+树，但B+树能够保证我们尽可能存储更多的元素，降低树的高度，因为树的高度越高，查询效率越慢，所以尽量矮和胖。并且不同存储引擎对索引的处理不一样，比如InnoDB和myisam，InnoDB索引和数据的文件不分开，一起存储，myisam索引和数据分开存储，不同的两个文件，（innodb支持事务， 支持行锁表锁，支持外键。myisam除了支持表锁其他都不支持）。索引并不是对所有数据的查询有效，有些时候会退化成全表查询，降低效率，比如like，这个时候需要对索引进行优化。

### 数据结构

**哈希表：**一、使用哈希表必须要保证良好的哈希算法，否则会导致哈希冲突，散列不均匀，有可能退化成链表。二、不支持范围查询，当需要范围查询的时候，需要整个进行对比。三、需要大量的内存

**二叉树、AVL、红黑树：**都是二叉树，只有两个分支，这就导致了存储过多的元素的时候会把树的高度称高，有可能会导致频繁的IO交互，从而降低查询效率。

> 局部性原理：时间局部性和空间局部性。数据和程序都有聚集成群的倾向，之前读取过的数据有可能很快被下一次读取。
>
> 磁盘预读：如果我从磁盘读取一个字符，是真的是读取一个字符嘛？内存跟磁盘之间在进行数据交互由一个最基本的逻辑单元，称之为“页”，或者叫“datapage”，不同的操作系统页的大小不同，一般是4k，innodb是默认读取一个磁盘块16kb数据。

 **B树、B+树：**

![](https://s3.bmp.ovh/imgs/2023/05/15/fa64094b13858409.png)

> **B树流程：** **注意此时磁盘中都带有数据。**每个磁盘块占16kb，当要查询28这个数据时，把磁盘块1加载进内存，发现28在16和34之间，要往p2指向的磁盘快3走，把磁盘块3加载进内存，之后再继续走，把磁盘块8加载进内存，找到数据28。一共就加载了48kb的数据，节省了很多空间。查询效率又高。
>
> **缺点：因为每个磁盘都带有数据，就会导致磁盘存储数据范围的缩小。比如一条数据1kb，磁盘占16kb，排除指针其他影响，也就说明一个磁盘最多16个范围的数据，我们查询三个磁盘，那也就只能表示16*16*16=4096范围数据，范围太小了。所以引出了B+树**

![](https://s3.bmp.ovh/imgs/2023/05/15/e32ea9d2a01f93a2.png)

> **B+树流程：注意除了叶子结点其他节点都不带数据。并且叶子节点是双指针。**流程与B树差不多。
>
> **优点：因为少了数据，存储的范围增大。一条数据1kb，磁盘占16kb，假设前两块磁盘指针啥的占1b，三块磁盘也就是，16*1000 * 16*1000 * 16 = 4096000000。**

**问题：主键是否要自增？**

> 答案是要的，原因是如果逐渐如果不自增，会导致页分裂，比如有个磁盘满了，然后现在随机插入了个这个范围内的数据，但是磁盘满了，这个时候会页分裂，把这个磁盘块分为两块，并且上头磁盘块的指针范围也需要跟着变动，因为多了一块，范围也变了，影响了两个磁盘块。所以每次都是往后面递增，就不会出现这样的情况。

**注意：**

> **1、InnoDB是通过B+Tree结构对主键创建索引，然后叶子节点存储数据，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6字节的row_id来作为主键。**
>
> **2、当要查询的数据为组合索引时，如果查询的数据为组合索引内部，索引不失效。**
>
> **3、当表中的字段全部为索引时，无论什么样的查询都会用到索引**
>
> **4、explain的key可以查看是否用了索引**
>
> **5、索引不是越多越好，会增加文件数量，增多IO次数**

**聚簇索引和非聚簇索引**

> **数据和（主键、唯一）索引放在一起的聚簇索引，否则为非。**

**索引其他名词**

> - 回表，会降低查询效率，所以尽量不要产生回表。如果创建（非主键、非唯一）索引的键是其他字段，那么在叶子节点中存储的是记录的主键，然后然后再通过主键索引找到对应的记录，叫做回表。
> - 索引覆盖，根据其他索引查询数据时，要查询的数据刚好在其他索引中，如select name，id from stu where name =‘saad’，其中name为其他索引。直接把数据返回，省了回表的操作。

**索引小优化**

> 根据explain的执行计划，查看key，type，Extra三个字段，key能够查看索引是否生效，且什么索引，type查看语句的执行效率，All代表需要优化，判断这三个，然后去决定做什么操作，比如之前我有个项目的时候，key值没有，加个索引字段

- 尽量不要在sql语句中加入计算业务，放到业务层中，而不是数据库。
- 尽量使用主键查询，而不是其他索引，因为主键索引不会产生回表。
- union all，in，or都能够使用索引，但是推荐使用in
- 范围列可以用到索引：> < >= <= bewteen and，范围可以用索引，但是范围后面的不能用索引，如a=1，b>5，c =6，c是不合格的
- 使用 or 会使索引会失效，在数据量较大的时候查找效率较低，通常建议使用 union 代替 or。

### 问题

**为什么Mysql可以存储百亿的数据？**

> 1、因为不管是Innodb还是myisam，数据和索引都是存储在硬盘中
>
> 2、当需要查询的时候，才会将磁盘中的数据读取到内存。
>
> 3、而且是分块读取数据（读取页的整数倍）



**MySQL的主从复制将经过如下步骤：**

1、当 master 主服务器上的数据发生改变时，则将其改变写入二进制事件日志文件中；

2、salve 从服务器会在一定时间间隔内对 master 主服务器上的二进制日志进行探测，探测其是否发生过改变，

如果探测到 master 主服务器的二进制事件日志发生了改变，则开始一个 I/O Thread 请求 master 二进制事件日志；

3、同时 master 主服务器为每个 I/O Thread 启动一个dump  Thread，用于向其发送二进制事件日志；

4、slave 从服务器将接收到的二进制事件日志保存至自己本地的中继日志文件中；

5、salve 从服务器将启动 SQL Thread 从中继日志中读取二进制日志，在本地重放，使得其数据和主服务器保持一致；

6、最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒





# 算法

- **AVG（条件）相当于sum（if（条件，1，0））/ count（全体）**

  **进阶sum（if（条件按，N，0））/ count（全体）可用N * avg（条件）代替**

- **count(if(条件，值1，值2)，sum(if(条件，值1，值2)**

























类型分类：

整形

| 类型名称      | 说明           | 存储需求 |
| :------------ | :------------- | :------- |
| TINYINT       | 很小的整数     | 1个字节  |
| SMALLINT      | 小的整数       | 2个宇节  |
| MEDIUMINT     | 中等大小的整数 | 3个字节  |
| INT (INTEGHR) | 普通大小的整数 | 4个字节  |
| BIGINT        | 大整数         | 8个字节  |

**如果整形类型后面跟了数据，代表数据可显示的长度，如果长度超了，Mysql还是会帮显示，自动增大**

浮点型

| 类型名称            | 说明               | 存储需求   |
| :------------------ | :----------------- | :--------- |
| FLOAT               | 单精度浮点数       | 4 个字节   |
| DOUBLE              | 双精度浮点数       | 8 个字节   |
| DECIMAL (M, D)，DEC | 压缩的“严格”定点数 | M+2 个字节 |

**如果浮点类型后面跟了数据，代表数据可显示的长度，比如（5，2），5代表总的长度，2代表小数点的长度，如果小数点长度超了，Mysql不会帮显示**

| 类型名称  | 日期格式            | 日期范围                                          | 存储需求 |
| :-------- | :------------------ | :------------------------------------------------ | :------- |
| YEAR      | YYYY                | 1901 ~ 2155                                       | 1 个字节 |
| TIME      | HH:MM:SS            | -838:59:59 ~ 838:59:59                            | 3 个字节 |
| DATE      | YYYY-MM-DD          | 1000-01-01 ~ 9999-12-3                            | 3 个字节 |
| DATETIME  | YYYY-MM-DD HH:MM:SS | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59         | 8 个字节 |
| TIMESTAMP | YYYY-MM-DD HH:MM:SS | 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC | 4 个字节 |

| 类型名称   | 说明                                         | 存储需求                                                   |
| :--------- | :------------------------------------------- | :--------------------------------------------------------- |
| CHAR(M)    | 固定长度非二进制字符串                       | M 字节，1<=M<=255                                          |
| VARCHAR(M) | 变长非二进制字符串                           | L+1字节，在此，L< = M和 1<=M<=255                          |
| TINYTEXT   | 非常小的非二进制字符串                       | L+1字节，在此，L<2^8                                       |
| TEXT       | 小的非二进制字符串                           | L+2字节，在此，L<2^16                                      |
| MEDIUMTEXT | 中等大小的非二进制字符串                     | L+3字节，在此，L<2^24                                      |
| LONGTEXT   | 大的非二进制字符串                           | L+4字节，在此，L<2^32                                      |
| ENUM       | 枚举类型，只能有一个枚举字符串值             | 1或2个字节，取决于枚举值的数目 (最大值为65535)             |
| SET        | 一个设置，字符串对象可以有零个或 多个SET成员 | 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） |

**如果字符类型后面跟了数据，代表数据字符长度，如果长度超了，Mysql不会帮显示，超了会报错varchar和char后面跟的数字只和字符数有关，跟字节数无关**