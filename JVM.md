---
title: JVM
date: 2023-02-22 12:47:45
categories: JVM
tags: java
---

# JVM

## 运行时数据区

> 推荐运行时数据区学习视频：https://www.bilibili.com/video/BV1f441127WK?p=6&spm_id_from=pageDriver&vd_source=dd5d1ef71c78ae671bcb138273ecb421

![](https://s3.bmp.ovh/imgs/2023/02/21/01b9cd12a65f3744.png)

1. **方法区线程共享，虚拟机启动时创建，方法区是逻辑上堆得一部分，所以有个名字叫非堆，存储着类的结构：**运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括类和实例初始化和接口初始化中使用的特殊方法。**内存无法满足分配请求，Java虚拟机会抛出一个内存不足OutMeoryError异常.**
2. **堆，线程共享，主要用来给类的实例和数组提供内存空间，内存不足时会抛出OutMeoryError异常**
3. 假设我们Java是一个进程，每个进程下有不同的线程，然后呢我们需要一种数据结构来帮我们执行Java的方法，就引入了栈，方法进入了栈，称为压栈，但我们Java方法又分为两类，一种是我们执行的Java方法，一种是native方法，由C++编写，我们编写的Java方法称为Java虚拟机栈，native方法称为本地方法栈，我们的线程不可能执行一个方法，这时候又有了执行方法的最小单元，栈帧，有多少个方法，就压多少个栈帧。这时候有线程分配到CPU的调度，该线程去执行他的方法，栈帧执行到一半的时候，其他线程分配到CPU的调度，该线程进入就绪状态，为了判断我们线程中的栈帧执行到哪一步，引入了程序计数器的概念。
4. **java虚拟机栈，执行Java方法，线程私有，栈满时抛StackOverflowError，深度。**
5. **java本地方法栈，执行本地方法，线程私有，栈满时抛StackOverflowError，深度。**栈帧记录每个方法执行的位置，方法正常执行完毕，调用return和抛出异常才会出栈。
6. **程序计数器，记录程序执行的位置（每一条指令都是一行行存在的，下面有例子0，2，3），线程私有，**

![](https://s3.bmp.ovh/imgs/2023/02/21/2eed0069f0304ce6.png)



### **栈帧**

- 局部变量表，存储变量，a = 10
- 操作数栈，存储临时的数据，把数据压栈，需要数据时出栈在入栈。（不会存a，b这种）
- 动态连接，找到方法在方法区所在的位置，存到动态连接中（这知识点不会）
- 方法出口，放的是主方法的一些信（主方法的行），因为一个方法执行完，肯定要返回继续走主方法的程序。

![](https://s3.bmp.ovh/imgs/2023/02/21/be6313b7b0744a30.png)

![](https://s3.bmp.ovh/imgs/2023/02/21/09cb0ac5df4d30a2.png)

**上图详细过程：**局部变量表和操作数栈相关性大一点，所以连起来讲，Ⅰ先当由i = 15时，把15压栈放到操作数栈中，然后，申请一块内存，i放到局部变量表里，然后才把15从操作数栈放到局部变量表下标为1的位置，Ⅱ 8放入到操作数栈中，之后再把j放入到局部变量表中，然后才把8放入到局部变量表下标为2的位置，此时i = 15，j = 8，Ⅲ 接着往下走，把i 和 j中在操作数栈的数据出栈，把k放入到局部变量表中，再把i和j在局部变量表中的数据压栈，在出栈进行一个求和，再把求和结果入栈，流程图，指令网上有https://www.cnblogs.com/wangbin2188/p/16020615.html。 

![](https://s3.bmp.ovh/imgs/2023/02/21/73cc3bde712fd8fb.png)

![](https://s3.bmp.ovh/imgs/2023/02/21/5777632ae3997828.png)

**上图详细过程：** 会解释出为什么在方法中a会去指向类中的成员变量。Ⅰ 因为a是类的属性，所以在局部变量表中会有个this指针，此时再把a在局部变量的数据放入到操作数栈中，Ⅱ  把b的数据放入到操作数栈中，压栈，再把b和c的出栈求和之后在进栈，再把进栈结果赋值到新的a中（putfield这个还能更深入）。

![](https://s3.bmp.ovh/imgs/2023/02/21/5996855253f61d7e.png)

## 垃圾回收器

> 推荐JVM学习视频：https://www.bilibili.com/video/BV1S34y1m7sX?p=1&vd_source=dd5d1ef71c78ae671bcb138273ecb421

**重要知识补充：**

1. **STW：即Stop the World，用处：当用户线程执行时，GC线程触发回收机制，此时会暂停用户线程的操作，等待GC操作结束。**

**分类：**

> 年轻代分为：① Serial GC，② ParNew GC，**③ Parallel Scavenge GC**
>
> 老年代分为： **① CMS GC**， ② SerialOld GC， **③ Parallel Old GC**
>
> 混合代分为：**① G1GC**，② ZGC

其关系如下：

### ![](https://s3.bmp.ovh/imgs/2023/02/19/c4a1eb8a8e268b83.png)

1. **1.8正在使用Paralled Scavenge GC + Paralled Old GC。**
2. CMS，Serial，Serial Old，ParNew 1.7之前使用过。
3. 虚线部分不再使用。

### Serial GC

其作为GC的鼻祖，serial意为串行，用于早期计算机由于处于单线程，单CPU的情况，当多线程的时候必须要等待GC处理完，才能继续执行任务，所以性能低下。



### ParNew GC/Serial Old GC

ParNew GC处理新生代，Serial Old处理老年代，他们与Serial GC最大的区别是引入了多线程并行去处理复杂的业务。处理流程如下：

![](https://s3.bmp.ovh/imgs/2023/02/19/a956a1635f04d1ba.png)

> 用户线程执行时，发现内存已满，需要垃圾回收，此时会促发一次STW（Stop the World）机制，清理完新生代，接着处理用户进程的业务，此时还会促发一次STW机制在处理老年代的。

### Parallel Scavenge GC/Parallel Old GC

Parallel Scavenge GC/Parallel Old GC，和ParNew GC/Serial Old GC的最大区别是Parallel Scavenge GC/Parallel Old GC能够达到可控制的吞吐量，且吞吐量优先。吞吐量关系图：

![](https://s3.bmp.ovh/imgs/2023/02/19/5f6979f6456f683b.png)

> 提供了两个参数去控制吞吐量：① 最大垃圾收集停顿事件：-XX: MaxGCPauseMills；② 控制吞吐量大小：-XX:GCTimeRatio；

**当然你不要想多了不要异想天开的认为如果把这个数的参数设置更小一点使得整个系统变得更快**

1、**垃圾停顿时间的缩短是以牺牲吞吐量和新生代的空间为代价换来的**

2、系统把整个新生代调小的小一点 收集300M 肯定比收集500M快 这也直接导致了收集发生更频繁 原来十秒收集一次每次停顿100毫秒 现在变成5s收集一次 每次停顿70毫秒 停顿时间的确在下降 但是吞吐量也降下来了

> 所以又出现了能够帮我们动态调节的参数：① -**XX:UseAdaptiveSizePolicy**

**他可以根据当前系统运行情况动态去调整新生代的大小，Eden区和Surivivor区的比例，以及晋升老年代的对象，然后呢达到一个最合适的停顿时间和吞吐量，称谓GC的自适应调节策略**



### CMS GC

**作为重点：CMS GC（并发标记GC）为将来的大型GC做了铺垫，不仅有内存碎片也有很严重的问题。所以随着版本的升级，1.6已经剔除CMS GC的使用，但仍需我们学习。其处理流程如下：**

![](https://s3.bmp.ovh/imgs/2023/02/19/d89ca56f70c7c423.png)

> **可分为四个阶段：① 初始标记；② 并发标记 ③ 重新标记； ④ 并发清理；以下详细说明改图的流程**



#### **阶段①：初始标记**

概念：**初始标记最重要的是从GC 根结点出发，找到那些活跃的对象，也就是能够被引用的对象**。**会促发STW**，当然，新生代的对象可能引用到老年代。

![](https://s3.bmp.ovh/imgs/2023/02/19/8348cc110b37123b.png)



#### **阶段②：并发标记**

概念：**所谓的并发，指的是用户线程和回收线程同步执行，而不需要用户线程暂停，从而提高了用户线程的执行效率。**

问题：由于用户线程和回收线程同步执行，因此随时可能会产生引用变更，**解决方法此阶段设置屏障，重新标记阶段写有**。比如：当我们GC扫完时，此时的用户线程执行操作时，又产生了新的垃圾对象，但是GC已经扫完，只能等待下次扫描，该垃圾称为浮动垃圾。**因为CMS主要关注低延迟，因而采用并发方式，清理垃圾时，应用程序还在运行，如何采用压缩算法，则涉及到要移动应用程序的存活对象，此时不停顿，是很难处理的，一般需要停顿下，移动存活对象，再让应用程序继续运行，但这样停顿时间变长，延迟变大，所以CMS采用清除算法。**



#### **阶段③：重新标记**

概念：**就是为了修正并发标记期间，因为用户线程继续运行而导致标记产生标动，这个阶段时间较长，主要用到三色标记算法解决。**

> **三色标记法：有三种颜色①黑色；②灰色；③白色。**
>
> 1. **黑色：代表该对象找到所有孩子，即引用对象。不为垃圾对象**
> 2. **灰色：代表该对象有爹引用他，但是可能还没开始找孩子。不为垃圾对象**
> 3. **白色：代表该对象是个孤儿。垃圾对象**
>
> **标记流程：根节点是否有孩子，有则全部找出来，根节点标为黑色，再找根节点的孩子，该孩子暂时标为灰色，因为有爹，还没找孩子，此时外面许多个白色节点。当下次又有一个GC线程时，会从该灰色节点开始，继续往下找孩子，提高了效率。**

![](https://s3.bmp.ovh/imgs/2023/02/19/133f67142fe9aa5d.png)

**面试加分项：但是三色标记发有个问题**。

​	① **当B节点引用C节点，此时断开引用时**，此时GC线程在执行，**发现C无人使用，会认为C是个垃圾对象**，需要回收。

![1676794422373](C:\Users\qinfeng\AppData\Roaming\Typora\typora-user-images\1676794422373.png)

![](https://s3.bmp.ovh/imgs/2023/02/19/566fbfd53a8168ff.png)

​	② 但是**此时用户线程抢到CPU的调度**，**A对象引用到C**，问题来了：GC线程拿到调度时，从B节点开始往下找，发现没有孩子了，**此时认为C是之前的白色，将C清理掉**，C= Null，A发现C怎么是Null，程序执行报错。

![](https://s3.bmp.ovh/imgs/2023/02/19/40494c0d4c4e4aa0.png)

**为了解决这个问题，需要在初始标记阶段进行操作，初始阶段引入了一个叫卡表的（Card Table）的数据结构，就是一个索引列表。并且会对每一个对象引用进行写操作之前和之后附加了一定的逻辑，称之为“写屏障”，写屏障会在对象发生引用变化的时候，记录到该表中。**如上诉问题：A引用C时，发现A时黑色，C是白色，会将A记录到卡表中。接下来到重新标记阶段时，会把卡表里的节点A重新设置成灰色，接下来会接着从A开始遍历，解决了这个问题。该方法叫**增量更新**。

**由于在CMS GC中的三色标记法存在更严重的问题，该问题导致CMS GC没能继续使用。该问题有些深奥，找到工作在学。**



#### **阶段④：并发清理**

由于被清除的对象都是未被使用的对象，因此在清楚操作进行中，是不需要 Stop The World 的，这一步操作也是和用户线程同步执行的。



### G1 GC

**G1 GC跟以前的GC区别很大，首先在我们知道，通常GC是以分代回收的，比如年轻代的Eden，s1，s2，老年代，但G1是以分区回收的，也就是划分成一小块的区域。每个区域大小相同，除了Humongous region，这个区域专门负责大对象，所有区域如下。**

![](https://s3.bmp.ovh/imgs/2023/02/19/9f3687be597853d1.png)

**G1中五种不同的Region**

- 新生代(Eden Region)
- 年轻代(Survivor Region)
- 老年代(Old Region)
- 巨型对象(Humongous Region)
- 未分配(Free Region)

**巨型对象区(Humongous Region)**

> Region中有一种特殊的`Humongous Region`,专门用来存储大对象。当大对象没有空间存储时，会触发Full GC，从而有连续的Humongous region能够存储大对象。

**对象划分的规则**

- 对象大小小于一半`Region`,直接存储到标记为Eden的Region
- 对象大小大于一半`Region`但是小于一个`Region`,存储到标记为Humongous的Region中
- 对象大小超过一个`Region大小`,存储到标记为Humongous的多个连续Region中

**GC类型**

- youngGC:回收Eden区和Survivor区
- MixedGC:回收所有的新生代和部分老年区
- FullGC:回收整个堆

**Remenber set**

> 每个区域单独存在，用于记录该区域引用别的区域对象。因为区域之间都是分散的，不可能我清除的时候，扫描全盘查引用对象，所以就诞生了Remenber set。

**回收过程**

等待补充

> 回收过程分为年轻代和老年代，因为采用算法不同。

1. 年轻代，也是采用标记复制算法，只不过多了Remenberd Set更快帮助我们复制对象到新的Service区域中。
2. 老年代，比较麻烦，也分好几个阶段采用的标记位图算法，有四个指针，两个根据对象引用情况进行位移，这方面较深，但是本质上还是采用三色标记处理浮动垃圾，对象不存在的问题。



### Full GC触发条件

> ① 在进行yong GC前，会先去判断老年代的最大连续可用空间跟新产生的对象的内存总和进行比较，Ⅰ 如果大于正常yong GC，Ⅱ 如果小于，则会去判断你是否开启了空间分配担保机制参数（-XX:+HandlePromotionFilure)，，如果没有开启，直接**Full GC**如果开启了，则会去赌一把判断，老年代最大连续可用空间是否大于历代YG之后进入老年代的对象所占内存空间的平均大小，如果小于，担保执行一次yong GC，如果担保失败，执行**Full GC**，担保成功，结束。
>
> ② 简单来说即使老年代的不足，或者连续空间不足。
>
> ③ 还有一些特殊的Full GC，比如Ⅰ 采用CMS GC回收器，因为该GC采用的标记-清除算法，会有内存碎片。Ⅱ 采用G1GC，因为G1属于逻辑上的分代，本质上分区，分区中有个Humongous 区，专门存取大对象，当有大对象且堆中区域不足时，Humongous也无法使用时，会调用一次Full GC，让出连续的区域，拼接成更大Humongous区。

## 基础

**Java运行流程：java文件通过javac（java编译器），是将java源文件，编译成字节码文件（.class），在经过ClassLoader类加载器，装载到内存，此时可能需要将一些Java类库的代码加载到加载器中，比如：Object，Date。ClassLoader在调用字节码解释器（将字节码翻译成机器识别的语言：0，1）或者JIT即使编译器（重复且特殊的代码放到这里，提高效率）来进行解释或编译，再由执行引擎进行执行，执行引擎下面就是操作系统和硬件了，流程如下：。** 

![](https://s3.bmp.ovh/imgs/2023/02/19/d3af3d419441902b.png)

**面试经典考题：为什么Java跨平台？**

> 因为Java通过java编译为字节码文件，而这个JVM只跟你的字节码有关，跟操作系统无关。字节码符合JVM的规范，就可以给你运行，所以它也支持跨语言，比如scala，kolin，这些语言也符合JVM的规范。

**JDK，JRE，JVM**

> JDK：包括JRE+开发工具包，负责开发。
>
> JRE：负责运行，只需要把.class文件交给他就行，包括JVM+核心类库（Object，Stream）。
>
> JVM：java虚拟机，把JVM流程说一遍得了。

**Java属于什么语言**

> **混合型语言，即解释器+热点编译器（JIT）**，可以进行参数设置修改成指定的模式，起始阶段采用解释执行，当发现某段特殊的代码执行频率特别高，就可以将这些交给热点编译器，生成本地代码，下次就不用再用解释器解释了，下次直接调用，提高效率。

**JVM何时加载**

> 大体可以说懒加载，但实际上你可以指定任何时候加载。

**JVM什么时候加载**

> - new 对象、访问静态实例，调用静态方法、但final除外，固定的，不需要初始化该类，就可以知道final的直；
> - java.lang.reflect反射
> - 初始化子类时，父类优先被初始化
> - 虚拟机启动时，被执行的朱磊必须初始化

### 类加载器

![](https://s3.bmp.ovh/imgs/2023/02/20/14a41c73b4f8a3d8.png)

#### ① 加载

> **类加载进内存时注意：**当.class文件通过类加载器加载到内存时，会分配**两块内存**，一块内存留给.class文件的代码，一块内存该.class的class对象，比如说：我加载了一个Person.class，此时会有Person的代码，还会产生Person的class对象，这就为我们反射提供了基础，所以说反射能够动态获取类的信息，因为程序在运行，该class对象存储到元空间哦，class对象帮我们解析好的字节码，所以我们才能调用，不能直接调用！！！

![](https://s3.bmp.ovh/imgs/2023/02/20/95e9f45e04d212ca.png)

**加载步骤：不同的类加载器负责加载不同的类；如下图**

**① 首先会从下至上委托**

- 会从Custom进行查找缓存中该类是否加载到内存，如果有则返回结果，无继续走；
- 向上委托App查找.......如果有则返回结果，无继续走；
- 向上委托Extension查找.......如果有则返回结果，无继续走；
- 向上委托Bootstrap查找.......如果有则返回结果，无，向下委托。

**② 其次以上步骤都找不到，从上至下委托**

- 会从Bootsrap向下委托；
- Extension只负责加载他jar包的内容（jre/lib/ext/*.jar），找着了，加载进内存，如果该类不属于该加载器，向下委托；
- App只负责加载我们定义过的类..............；
- Custom 只负责加载我们定义过的类............如果该类不属于该加载器，抛异常（ClassNotFound）；

**面试经典题：为什么要双亲委派机制？**

> 主要是为了安全，比如我自己写一个自定义的java.lang.String类，通过自定义加载类加载进内存，然后打包成jar包，给客户，然后客户使用输入密码的时候，给自己发送一封邮件，这样就不安全了，密码泄露了，所以就有双亲委派，当看到Bootstrap时，就不会加载我们String类了。

![](https://s3.bmp.ovh/imgs/2023/02/20/edc3ee9499450028.png)

> rt.jar存储着核心类比如：Object，String，所以该类属于Bootsrap类加载时，你调用类.class.getClassLoader时，输出的值为null，因为Boostrap类加载底层是由C++实现的，java没有类能跟他对应。
>
> APP这部分主要加载我们自己写的类，所以类.class.getClassLoader的时候都是自己的包路径。



**类加载器范围（作用域）**

`可以自己打印出来看看，比如：sum.misc.Launcher$APPClassLoader@12qwe，其中中间的$符号代表Launcher类下的子类，所以可以到Launcher下查找范围，每个加载器的有不同的路径。通过字符串拼接`



#### ② 连接

1. Verification（验证）

   验证文件是否符合JVM规范

2. Prepartaion（准备）

   静态成员变量赋初值

3. Resolution（解析）

   将类、方法、属性等符号引用解析为直接引用，常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用。 

   符号引用：我们用的是时候实际上指的是字符串，$，Luncher$APPClassLoader，所以就要通过偏移量计算得到内存地址。

#### ③ 初始化

1. 调用初始化代码



**经典考题**

![](https://s3.bmp.ovh/imgs/2023/02/20/682587aee41ea9c9.png)





> 输出结果：3
>
> **加载 ---》 连接（验证、准备、解析） ---》 初始化**记住这几个阶段。
>
> **①** 首先加载阶段，将T.class加载进内存，通过我们的ClassLoader，因为这是我们自己自定义的类，所以就是APPClassLoader，**②** 进入链接阶段，先验证是否符合JVM的规范，在准备阶段对count给初值0，t初值为null，**③** 初始化阶段，count值赋值为2，t = new T（），t赋值了，走到构造方法，对count++，count值为3。



![](https://s3.bmp.ovh/imgs/2023/02/20/ba6563084ac7d5c0.png)









> 输出结果：2
>
> **加载 ---》 链接（验证、准备、解析） ----》 初始化**记住这几个阶段。
>
> **①** 首先初始化加载阶段，因为调用了静态变量，所以会将该类加载进内存，先通过javac编译器，编译为字节码文件，再通过类加载器加载内存，因为这是我们自己写的类，所以属于APPClassLoader的范围，通过它进行加载。 **②** 连接阶段，Ⅰ 验证，先验证这段代码是否符合JVM规范，Ⅱ 准备，给静态变量赋初值，所以**t = null，count = 0**，Ⅲ......**③** 初始化 进行赋值操作，此时count = 0，t = new T()，走到构造方法，count++，count为1，继续走，count = 2，所以最终值为2。



**经典考题：单例对象为何要加Volatile**

![](https://s3.bmp.ovh/imgs/2023/02/20/753a53c1b43ef19f.png)

> 首先，为了实现单个同一对象，因为不希望外部直接能创建新的对象，所以构造方法设为私有，使用static去修饰该类的对象，当然可以直接去实例化，但是这种我们不用到的时候会直接初始化，浪费资源，太着急了，这种叫饿汉式，所以进一步优化，直接创建一个方法，用来返回一个该类的对像，加上判断条件为空的时候才去创建，但是会产生多线程的问题，所以又在这个方法上，加了一个synchronize锁，但是这样效率也太低了，然后又在方法的内部进行了加锁，不过首先需要去判断对象是否为空，如果为空，再去锁住资源，但是多线程来的时候，第一个线程进来，判断为空，走到if和synchronized的中间就停了，第二线程拿到CPU的调度，此时，判断对象为空，继续往下走，拿到锁资源，并初始化对象，释放锁，但是第一个线程继续往下走，又创建了一个新的对象，为了解决这个问题，synchronized里外面和里面都加了检查，双重检查。
>
> votitle：细节如下。

## 对象创建过程

当创建一个对象的时候，会去申请一块内存空间，当有成员变量时，比如 int a = 9，根据new，这个成员变量会先赋默认值，默认值为0，根据汇编指令，当继续往下走的时候，调用特殊的方法，也就是构造方法，才会去赋值给8。对象的创建过程有个半初始化过程，astore就是变量跟新new出来的对象之间建立关联。

![](https://s3.bmp.ovh/imgs/2023/02/20/f193880df38a6080.png)

### volatitle

> 修饰一个变量时：① 代表线程之间可见， ② 禁止重排序

> **指令重排序：** 因为CPU执行很快，做了很多优化，比如当执行两条不相关的指令时，指令1 - 去内存读取数据，但是内存比CPU很慢，需要CPU等待，所以先让指令2先走，必须两条指令无任何关系。

> 线程导致指令重排：线程1进来，当创建一个对象的时候，会先去内存申请一块空间，然后，有成员变量时，会先赋初值，正好在这个时间，发生指令重排序，将执行构造方法的指令和连接的指令进行了一个重排序，先变量t连接到new 出来的对象，当前m = 0，这时线程2进来了，拿到m = 0这个值就去用了，并且不为空，单例里面就直接拿去用了，导致资源发生混乱。

### 对象如何定位

> 分为句柄方式和直接方式（当前jdk使用）

### 对象怎么分配

![](https://s3.bmp.ovh/imgs/2023/02/20/ce761f7588b61e3c.png)



**程序运行步骤（简化）**

> 首先程序.exe在磁盘上，双击运行的时候，操作系统会从硬盘Load到内存，会在内存中形成一个进程，包括一条条的指令，一条条的数据，接下来，CPU会一点点拿到指令在内部执行，需要数据的时候再把数据读取过来。

![](https://s3.bmp.ovh/imgs/2023/02/20/9466da5eed26bdad.png)



