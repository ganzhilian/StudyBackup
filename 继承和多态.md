---
title: 继承和多态
date: 2021-07-31 08:53:50
categories: java
tags: java
---

# OO练习

## 业务类和实体类合二为一

> 居然将业务方法放在了实体类中 - **违背了设计原则 - "单一职责原则".不要给一个类增加太多的负担**
>
> 实体类 - 主要是描述对象,数据在内存中的载体 - 注重的应该是数据的**存储**
>
> 业务类 - 存放的是业务方法 - 在于**操作**这些数据

> 员工类[编号id,姓名name,工资salary]
>
> 业务方法[crud增删改查]放在实体类中 - 不合理的.
>
> ```java
> public class Emp{     
> private int id;
> 
> private String name;
> 
> private double salary;
> 
> //一个上司拥有多个下属
> //一个下属对应一个上司
> 
> //自关联
> private Emp[] emps;
> 
> //构造,getter/setter,toString
> 
> //给上司添加一个下属
> public void addEmp(Emp e){
>  //数组的扩容Arrays.copyOf(数组对象,新的长度);
> }
> 
> //输出下属的个数
> public void printEmpCount(){
>  
> }
> 
> //输出某个上司所有的下属信息
> public void printEmp(){
>  
> }
> }
> 
> //TestEmp.java
> Emp boss = new Emp(1,"boss",100.0,new Emp[0]);
> 
> Emp e1 = new Emp(1,"boss",100.0,null);
> ```

## 业务类和实体类分开

> 业务方法应该专门抽取出来放到一个业务类中.
>
> ```java
> public class Account{
> private int id;
> 
> private double balance;//余额
> 
> //...
> }
> ```
>
> ```java
> public class AccountBiz{
> //转钱
> public void test01(Account acc1,Account acc2,double money){
>  
> }
> 
> 
> //存钱
> }
> ```



# 继承Inheritance

> **将多个具有共同特点的对象抽象出一个"父类"**.继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法
>
> 父类中存储的是各个子类共同的特点[属性]或者功能[方法]
>
> 继承的好处 - 提高了代码的复用性.使用多态的前提,为了代码的可拓展性.
>
> 继承的缺点 - 增加了类与类之间的关系.不太符合软件的设计原则"高内聚,低耦合"
>
> ​					  低耦合 - 模块与模块之间/类与类之间的关系应该越弱越好 - 没有关系
>
> ​					  高内聚 - 单个模块/类能够独立完成某个业务功能的能力比较强.
>
> ​					  实际开发中,可以采用设计原则**"合成复用原则"** - 来替代继承的使用.
>
> 使用extends关键字来表示某个类继承某个父类
>
> 比如:
>
> ```java
> public class A{
> 
> }
> public class B extends A{
> 
> }
> B 是 A的子类,A是B的父类,基类,超类.
> 1. A的父类就是java.lang.Object - 当某个类如果没有明确指定它的父类是谁,那么这个类默认继承Object
> 2. 子类是可以访问到父类中所有的非私有的成员
> 3. java的类只支持单继承.一个类只能继承一个父类.避免出现网状结构,保证类的层次性.
> java中的接口是支持多重继承.一个接口可以继承多个接口.
> 4. 继承具有传播性.C extends B    B extends A
> C间接继承于A,C也是可以访问到A中的所有的非私有的成员
> 5. 不要滥用继承,前提B is A
> ```



## super关键字

> 必须放在构造方法的首行

> 1. 调用父类的构造
>
> 在子类的构造中,如果没有出现任何的super语句.那么系统默认会给定super(); - 调用父类的空参构造
>
> 如果父类有有参构造方法, 没有写无参构造, 子类的super()默认会调用父类的无参构造, 导致了父类没有写无参构造报错, 一种方法是父类加上无参构造, 一种是子类super(参数)指定父类的有参构造
>
> 
>
> 2. 当在子类中调用了一个和父类中同名的成员的时候,需要通过super关键字来加以区分[强制调用父类中那个同名的成员]



# 多态 - polymorphism

> 对象有多种形态.发生前提是具有**继承关系**

> 相同的消息可能会送给多个不同的类别之[对象](https://baike.baidu.com/item/对象)，
>
> 而系统可依据对象所属类别，引发对应类别的方法，而有不同的行为。简单来说，所谓多态意指相同的消息给予不同的对象会引发不同的动作。



## instanceof

> 进行类型的判断,只有为true的时候,才能够进行类型的转换[强制,向下]
>
> 如果没有进行类型的判断,随便进行了一个强制类型转换,可能会抛出java.lang.ClassCastException类型转换失败异常



## 三种场景应用

> 面向父类编程

> 1. 对象的编译时类型写成父类,对象的运行时类型写成子类
>
> **编译时类型 对象名 = new 运行时类型();**
>
> 对象的编译时类型决定了对象的访问能力 - "对象名只能访问到编译时类型中定义的成员"
>
> 对象的运行时类型决定了对象的行为能力 - "子类中如果一旦重写了父类中的方法,那么运行期间调用的是子类重写之后的方法"
>
> 2. 方法的参数类型写成父类,调用这个方法的时候,可以传入这个父类的任意一个子类对象
> 3. 方法的返回类型写成父类,方法的返回结果可以是这个父类的任意一个子类对象  - "简单工厂设计模式"



# final关键字

> 不可更改,不可变

> 1. final修饰的变量/属性 - 不能够重新赋值
> 2. final修饰的类 - 不能够被继承
> 3. final修饰的方法不能够被重写.



# 修饰符

> 访问修饰符 - 决定了这个成员可以在哪里能够被访问.

| 权限修饰符 | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| ---------- | -------- | -------- | ------------ | -------------- |
| Private    | √        |          |              |                |
| Default    | √        | √        |              |                |
| Protected  | √        | √        | √            |                |
| Public     | √        | √        | √            | √              |

> **安全级别:private>默认的>protected>public**  
>
> 可见区域:public>protected>默认的>private



# 方法的重写

> 方法的重载和方法的重写有什么区别?
>
> 特点:
>
> 发生的前提是要有继承关系
>
> 1. 重写有个特殊的场景 - 子类重写之后的方法的修饰符,返回类型,方法名,参数列表和父类中高度保持一致 - **重构**
> 2. 访问权限不能比父类中被重写的方法的访问权限更低
> 3. 方法名必须要一样.
> 4. 子类重写的方法的返回类型可以小于[可以是父类方法的返回类型的子类类型]或者等于父类的那个方法
> 5. 参数列表必须要高度保持一致



# 作业

```java
1.设计一个形状类Shape,方法:求周长和求面积
  形状类的子类:Rect(矩形),Circle(圆形)
  Rect类的子类:Square(正方形)
  不同的子类会有不同的计算周长和面积的方法
  创建三个不同的形状对象
  分别打印出每个对象的周长和面积
  [girth() area() -> 放在父类]
  [每个子类需要重写这些方法!] - 不要想太多应用场景,语法!


2.某公司的雇员分为以下若干类：
Employee：这是所有员工总的父类，
属性：员工的姓名,员工的生日Date。
方法：getSalary(int month) 
根据参数月份来确定工资，
如果该月员工过生日，则公司会额外奖励100元。

SalariedEmployee：
Employee的子类，拿固定工资的员工。属性：月薪

HourlyEmployee：
Employee的子类，按小时拿工资的员工，
属性：每小时的工资、每月工作的小时数
每月工作超出160小时的部分按照1.5倍工资发放。

SalesEmployee：
Employee的子类，销售人员，工资由月销售额和提成率决定。
属性：月销售额、提成率

BasedPlusSalesEmployee：
SalesEmployee的子类，有固定底薪的销售人员，
工资由底薪加上销售提成部分。属性：底薪。

写一个函数，打印出某月每个员工的工资数额。

注意：要求把每个类都做成完全封装，不允许非私有化属性。
```











